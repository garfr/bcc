//===-------------------- emit.c - QBE Code Emmiter ----------------------===//
//
// Part of BCC, which is MIT licensed
// See https//opensource.org/licenses/MIT
//
//===----------------------------- About ---------------------------------===//
//
// Taking the AST as input, this generates IR for the QBE backend, which can
// then be used to generate assembly.
//
//===---------------------------------------------------------------------===//

#include <ast.h>
#include <emit.h>
#include <stdio.h>
#include <stdlib.h>
#include <tac.h>

char* translateType(Type* type) {
    switch (type->type) {
        case TYP_S8:
        case TYP_U8:
            return "b";
        case TYP_S16:
        case TYP_U16:
            return "h";
        case TYP_S32:
        case TYP_U32:
            return "w";
        case TYP_S64:
        case TYP_U64:
            return "l";
        case TYP_VOID:
            return "";
        default:
            printf("Cannot translate that type yet.\n");
            exit(1);
    }
}

static int newTemp() {
    static int value = 0;
    return value++;
}

char* translateOp(int i) {
    switch (i) {
        case BINOP_ADD:
            return "add";
        case BINOP_SUB:
            return "sub";
        case BINOP_MULT:
            return "mul";
        case BINOP_DIV:
            return "div";
        default:
            printf("ErROR: Cannot translate this operation yet.\n");
            exit(1);
    }
}

/* Returns the tempory the value is located in */
int generateExpr(Expr* exp) {
    switch (exp->type) {
        case EXP_INT: {
            int temp = newTemp();
            printf("\t%%%d =l copy %.*s\n", temp, (int)exp->intlit.len,
                   exp->intlit.text);
            return temp;
        } break;
        case EXP_BINOP: {
            int loc1 = generateExpr(exp->binop.exp1);
            int loc2 = generateExpr(exp->binop.exp2);
            int temp = newTemp();
            printf("\t%%%d =l %s %d, %d\n", temp, translateOp(exp->binop.op),
                   loc1, loc2);
            return temp;
        }

        default:
            printf("ERROR: Cannot compile expressions yet.\n");
            exit(1);
    }
}

void generateStmt(Stmt* stmt) {
    switch (stmt->type) {
        case STMT_DEC:
            // noop
            return;
        case STMT_ASSIGN: {
            int temp = generateExpr(stmt->assign.value);
            printf("\t%%%.*s =l copy %%%d\n", (int)stmt->assign.var->id.len,
                   stmt->assign.var->id.text, temp);
            break;
        }
        case STMT_DEC_ASSIGN: {
            int temp = generateExpr(stmt->assign.value);
            printf("\t%%%.*s =l copy %%%d\n", (int)stmt->dec_assign.var->id.len,
                   stmt->dec_assign.var->id.text, temp);
            break;
        }
        default:
            printf("ERROR: Cannot compile statements yet.\n");
            exit(1);
    }
}
void generateFunction(Function* fn) {
    printf("export function %s $%.*s(", translateType(fn->retType),
           (int)fn->name.len, fn->name.text);

    if (fn->params->numItems != 0) {
        size_t i;
        for (i = 0; i < fn->params->numItems - 1; i++) {
            Param par = *((Param*)indexVector(fn->params, i));
            printf("%s \%%%.*s, ", translateType(par.type),
                   (int)par.var->id.len, par.var->id.text);
        }
        Param par = *((Param*)indexVector(fn->params, i));
        printf("%s \%%%.*s", translateType(par.type), (int)par.var->id.len,
               par.var->id.text);
    }
    printf(") {\n\t@start\n");

    for (size_t i = 0; i < fn->stmts->numItems; i++) {
        Stmt* stmt = *((Stmt**)indexVector(fn->stmts, i));
        generateStmt(stmt);
    }
}

void generateCode(AST* ast) {
    for (size_t i = 0; i < ast->decs->numItems; i++) {
        Toplevel top = *((Toplevel*)indexVector(ast->decs, i));
        generateFunction(top.fn);
    }
}
